#!/bin/bash

# --- template --- {{{
readonly cf="\\033[0m"
readonly red="\\033[0;31m"
readonly green="\\033[0;32m"
readonly yellow="\\033[0;33m"

err() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${red}ERROR${cf}]: $1" 1>&2
}

warn() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${yellow}WARNING${cf}]: $1"
}

info() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][INFO]: $1 "
}

succ() {
  local _date
  _date=$(showdate)
  echo -e "[$_date][${green}SUCCESS${cf}]: $1"
}

showdate() {
  local _date
  _date=$(date +%d-%H.%M)
  echo "$_date"
}

cleanup() {
  info "cleanup.."
}
#}}}

show_help() {
  cat <<'EOF'

USAGE:
  runeboxes [options] <box_char>

OPTIONS:
  -h: help
  -p: padding size
  -x: horizontal padding size
  -y: vertical padding size

EXAMPLE:
  echo apple | runeboxes @
  echo banana | runeboxes -p 3 \$
  echo -e "\U1F4A9" | runeboxes -x 8 -y 2 é‡‘
  fortune | cowsay -W 60 | runeboxes -x 4 $(echo -e "\U1F4A9")
EOF
}

run_runeboxes() {
  local in
  local max
  local singles
  local frame_empties
  local lens
  local l
  local i

  # read stdin
  in="$(cat -)"

  # tab_to_space
  in="$(tab_to_space "$in")"

  # set max and read liens
  while read -r l; do
    if [[ $(runewidth "$l") -gt $max ]]; then
      max=$(runewidth "$l")
    fi
    lines+=("$l")
  done <<<"$in"

  # make max to even if box_char_runewidth is 2
  if [[ "$box_char_runewidth" -eq 2 ]]; then
    if [[ $((max % 2)) -ne 0 ]]; then
      max=$((max + 1))
    fi
  fi

  singles="$((max + $((box_char_runewidth * 2)) + $((box_padding_x * 2))))"
  frame_empties="$((singles - $((box_char_runewidth * 2))))"
  lens="$((singles / box_char_runewidth))"

  # top border
  display_border_line "$1" "$lens"
  display_new_line

  # top empty frame
  for ((i = 0; i < "$box_padding_y"; i++)); do
    display_empty_frame_line "$1" "$frame_empties"
    display_new_line
  done

  # input lines
  for l in "${lines[@]}"; do

    display_front_padding_block "$1"

    printf "%s" "$l"

    display_string_n_times ' ' $((max - $(runewidth "$l")))

    display_back_padding_block "$1"

    display_new_line
  done

  # bottom empty frame
  for ((i = 0; i < "$box_padding_y"; i++)); do
    display_empty_frame_line "$1" "$frame_empties"
    display_new_line
  done

  # bottom border
  display_border_line "$1" "$lens"
  display_new_line
}

display_string_n_times() {
  local i
  if [[ 0 -ne $2 ]]; then
    for ((i = 1; i <= $2; i++)); do
      printf "%s" "$1"
    done
  fi
}

display_empty_block() {
  printf ' '
}

display_front_padding_block() {
  printf "%s" "$1"
  display_string_n_times ' ' "$box_padding_x"
}

display_back_padding_block() {
  display_string_n_times ' ' "$box_padding_x"
  printf "%s" "$1"
}

display_border_line() {
  display_string_n_times "$1" "$2"
}

display_new_line() {
  printf "\n"
}

display_empty_frame_line() {
  printf "%s" "$1"
  display_string_n_times ' ' "$2"
  printf "%s" "$1"
}

tab_to_space() {
  # shellcheck disable=SC2001
  echo "$1" | sed -e 's/\t/    /g'
}

is_pipe() {
  if [ -p /dev/stdin ]; then
    return 0
  elif [ -p /dev/stdout ]; then
    return 0
  else
    return 1
  fi
}

is_exists() {
  which "$1" >/dev/null 2>&1
  return $?
}

is_number() {
  if [[ "$1" =~ ^[0-9]+$ ]]; then
    return 0
  else
    return 1
  fi
}

err_exit() {
  err "$1"
  if [[ -z "$2" ]]; then
    exit 0
  else
    exit "$2"
  fi
}

exit_health() {
  if [[ -n "$1" ]]; then
    info "$1"
  fi
  exit 1
}

exit_quit() {
  err "quit" 1>&2
  exit 1
}

# locale
export LC_ALL=C

# IFS
IFS=""

# trap
trap exit_quit QUIT SIGINT

# vars
box_padding_x=2
box_padding_y=1
box_char="#"
box_char_runewidth=1

## error code
err_code_invalid_option=3
err_code_invalid_arguments=4
err_code_invalid_box_char_width=5
err_code_invalid_input=6
err_code_not_found_runewidth=7

if [[ -z "$1" ]]; then
  box_char="#"
else
  box_char="$1"
fi

# flag option cases
while getopts ":htpxy" o; do
  case "${o}" in
  h)
    show_help
    exit_health ""
    ;;
  p)
    if [[ "$#" -eq 2 || "$#" -eq 3 && "$1" == "-p" ]]; then
      if [[ "$#" -eq 2 ]]; then
        box_char="#"
      else
        if [[ -z $3 ]]; then
          box_char="#"
        else
          box_char="$3"
        fi
      fi
      if is_number "$2"; then
        box_padding_x="$2"
        box_padding_y="$2"
      else
        err_exit "Invalid -p option usage" "$err_code_invalid_option"
      fi
    else
      err_exit "Invalid -p option usage" "$err_code_invalid_option"
    fi
    break
    ;;
  x)
    if [[ "$1" == "-x" ]]; then
      if [[ "$#" -lt 2 || "$#" -gt 5 ]]; then
        err_exit "Invalid -x option usage" "$err_code_invalid_option"
      fi
      if is_number "$2"; then
        box_padding_x="$2"
      else
        err_exit "Invalid -x option usage" "$err_code_invalid_option"
      fi
      if [[ -z "$3" ]]; then
        box_char="#"
      elif [[ "$3" == "-y" ]]; then
        if [[ -z "$4" || -n "$6" ]]; then
          err_exit "Invalid -x -y option usage" "$err_code_invalid_option"
        else
          box_padding_y="$4"
          if [[ -n "$5" ]]; then
            box_char="$5"
          else
            box_char="#"
          fi
        fi
      else
        if [[ -n "$4" ]]; then
          err_exit "Invalid -x -y option usage" "$err_code_invalid_option"
        else
          box_char="$3"
        fi
      fi
    fi
    break
    ;;
  y)
    if [[ "$1" == "-y" ]]; then
      if [[ "$#" -lt 2 || "$#" -gt 5 ]]; then
        err_exit "Invalid -y option usage" "$err_code_invalid_option"
      fi
      if is_number "$2"; then
        box_padding_y="$2"
      else
        err_exit "Invalid -y option usage" "$err_code_invalid_option"
      fi
      if [[ -z "$3" ]]; then
        box_char="#"
      elif [[ "$3" == "-x" ]]; then
        if [[ -z "$4" || -n "$6" ]]; then
          err_exit "Invalid -x -y option usage" "$err_code_invalid_option"
        else
          box_padding_x="$4"
          if [[ -n "$5" ]]; then
            box_char="$5"
          else
            box_char="#"
          fi
        fi
      else
        if [[ -n "$4" ]]; then
          err_exit "Invalid -x -y option usage" "$err_code_invalid_option"
        else
          box_char="$3"
        fi
      fi
    fi
    break
    ;;
  *)
    err_exit "Invalid option" "$err_code_invalid_option"
    show_help
    ;;
  esac
done

box_char_runewidth="$(runewidth "$box_char")"

# run
if [[ -z "$box_char" ]]; then
  err_exit "Argument is required" "$err_code_invalid_arguments"
elif [[ "$box_char_runewidth" -gt 2 ]]; then
  err_exit "String is over 2 runewidth" "$err_code_invalid_box_char_width"
elif ! is_pipe; then
  err_exit "Pipe input is requird" "$err_code_invalid_input"
elif ! is_exists "runewidth"; then
  err_exit "Command not found: runewidth" "$err_code_not_found_runewidth"
else
  out="$(run_runeboxes "$box_char")"
  echo "$out"
fi
